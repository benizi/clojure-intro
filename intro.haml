%head
  %title Intro to Clojure
.slide
  %h1 Intro to Clojure

.slide
  %h2 About Me
  %ul
    %li
      :marked
        [Benjamin R. Haskell](http://benizi.com):
        Twitter [@benizi](https://twitter.com/benizi),
        GitHub [benizi](https://github.com/benizi)
        Web [benizi](http://benizi.com/)
    %li
      Day Job:
      :marked
        [Forever&trade;](https://www.forever.com/)
      (mostly Ruby)
    %li
      Worked professionally with
      %ul
        %li Perl, .NET (C♯, VB), JavaScript, PHP, Ruby
    %li
      Strong interests in
      %ul
        %li Go, Clojure, Erlang, Haskell, and Python
    %li
      Like tools that require a lot of configuration/practice to "get":
      %ul
        %li Vim, Zsh, Linux, XMonad

.slide
  %h2 Clojure and Me
  %ul
    %li Interested in Clojure for a couple of years
    %li No production experience
    %li I hate virtually all of my Clojure code, despite making it available
    %li
      :marked
        Solved all [4clojure.com](https://www.4clojure.com) problems.

.slide
  %h2 Clojure and Me - Toy apps
  %ul
    %li
      :marked
        [yu2.be](http://yu2.be/)
      %ul
        %li really simple YouTube® link shortener
        %li Running on Heroku
    %li
      :marked
        [these slides](https://github.com/benizi/clojure-intro)
      %ul
        %li
          :marked
            [Ring](https://github.com/ring-clojure/ring)/[Compojure](https://github.com/weavejester/compojure) application
        %li that parses HAML/Markdown with Ruby
        %li
          Munges deck.js templates with
          :marked
            [enlive](https://github.com/cgrand/enlive)
        %li Syntax highlighting with Pygments (in Ruby)

.slide
  %h2 Immutability
  %ul
    %li
      Mutability causes bugs, action at a distance
      :rubycode
        # Ruby
        puts data.inspect # { vital_data: 1, other: 2 }

        def evil_function(param)
          param.delete(:vital_data)
        end

        evil_function(data)

        puts data.inspect # { other: 2 }
    %li
      "But isn't immutability inefficient?"
      %ul
        %li Everything is "pass by value"
        %li Lots of data copying

.slide
  %h2 Hash-Array Mapped Tries
  :marked
    ![tree structure](/images/persistenthashmap1.png)
  :marked
    ![path copying](/images/persistenthashmap-pathcopy.png)

.slide
  %h2 Hash-Array Mapped Tries
  %ul
    %li
      Core data structures all Hash-Array Mapped Tries
      %ul
        %li Elegant: Structural sharing minimizes copying
        %li Clever: 5-bit indices squashed into 32-bit ints
        %li Efficient: O(log<sub>32</sub>(N)) operations (effectively O(1))
    %li
      Doesn't extend to Java objects
      %ul
        %li Mutability is a big concern with Java interop
  %p
    :marked
      Highly recommended reading: [Karl Krukow blog post](http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html)

.slide
  %h2 Clojure
  %ul
    %li Follow along(!)
    %li
      :marked
        [Himera](http://himera.herokuapp.com) - online ClojureScript REPL by [@fogus](https://twitter.com/fogus).
    %li
      :marked
        [http://himera.herokuapp.com](http://himera.herokuapp.com)
    %iframe{:src => "http://himera.herokuapp.com/index.html",
            :style => "width: 100%; min-height: 4in",
            :scrolling => "no"}

.slide
  %h2 Clojure Basics - Comments
  %ul
    %li
      Comments
      :clojurecode
        ; line-based
        ; everything after ";" ignored by reader

        ;; function-like
        (comment ...) ; => nil
        [1 (comment 2) 3] ; => [1 nil 3]

    %li
      REPL conventions
      :clojurecode
        user=> input ; this is user input
        ; output     ; this is printed output
        ; => val     ; this is a returned value

.slide
  %h2 Other comment types
  :clojurecode
    ;; Reader macro #_
    #_(...) ; form is completely elided
    [1 #_2 3] ; => [1 3]

    ;; #! shell compatibility
    #!/usr/bin/clojure      ; not usually a thing,
                            ; but would be ignored

.slide
  %h2 Clojure Basics - nil, bools
  %ul
    %li
      nil = equivalent to Java null
      :clojurecode
        nil
    %li
      Booleans are Java Booleans
      :clojurecode
        true false
    %li
      Only nil and false are "falsey"

.slide
  %h2 Clojure Basics - numerics
  %ul
    %li
      Clojure has several built-in numeric types
      :clojurecode
        (map class [
          1      ; => java.lang.Long
          1.2    ; => java.lang.Double
          1/2    ; => clojure.lang.Ratio
          1N     ; => clojure.lang.BigInt
          1M     ; => java.math.BigDecimal
        ])

.slide
  %h2 Clojure Basics - Strings
  :clojurecode
    (class "asdf") ; => java.lang.String    ;; Strings

    ;; strings are sequences of characters
    (map identity "asdf") ; => (\a \s \d \f)

    ;; A few special names for characters
    (first "\n") ; => \newline

    ;; Just Characters underneath
    (class \newline) ; => java.lang.Character

    (def item "yay")
    ;; str stringifies and joins
    (str "a" item "b") ; => "ayayb"

.slide
  %h2 Clojure Basics - Regexps
  :clojurecode
    #"regular expression"
    (class #"regular expression")
    ; => java.util.regex.Pattern

    ; fewer backticks: #"\d" is like "\\d"

    (re-seq #"\w" "asdf")
    ; => ("a" "s" "d" "f")

    (re-find #"sd" "blah asdf blah")
    ; => "sd"
    (re-find #"sd" "blah blah blah")
    ; => nil

.slide
  %h2 Clojure Basics - Symbolics
  :clojurecode
    'some-thing       ; => some-thing       ;; Symbols
    'whatever/thing   ; => whatever/thing (namespaced)
    'questionable?    ; => questionable?
    'warn-!-yay       ; => warn-!-yay

    (name :stringy)   ; => "stringy"        ;; Keywords
    ::resolved        ; => :user/resolve
    (in-ns 'whatever)
    ::resolved        ; => :whatever/resolve

.slide
  %h2 Clojure Basics - List-alikes
  :clojurecode
    (list 1 2 3) ; => (1 2 3)        ;; Lists

    ; quote prevents evaluation
    '(1 2 3) ; => (1 2 3)

    [1 2 3]                          ;; Vectors
    (vec '(1 2 3))  ; => [1 2 3]
    (vector 1 2 3)  ; => [1 2 3]
    ([5 6 7] 0)     ; => 5

.slide
  %h2 Clojure Basics - Indexed seqs
  :clojurecode
    {:a 1 :b 2}                                 ;; Maps
    (hash-map :a 1 :b 2)   ; => {:a 1, :b 2}
    (sorted-map :a 1 :b 2) ; => {:a 1, :b 2}
    ({:a 1 :b 2} :a)       ; => 1
    ({:a 1 :b 2} :c)       ; => nil

    #{:a :b :c}                                 ;; Sets
    (hash-set :a :b :c)   ; => #{:a :b :c}
    (set [:a :b :c])      ; => #{:a :b :c}
    (sorted-set :a :b :c) ; => #{:a :b :c}

.slide
  %h2 Clojure - Order of operations
  :clojurecode
    ;; 1. Read - Convert string representation to data
    (read-string "(1 2 3)") ; => (1 2 3)

    ;; 2. Macro expansion - Recursively expand macros
    (macroexpand '(defn foo [a] (+ 1 a)))
    ; => (def foo (clojure.core/fn ([a] (+ 1 a))))

    ;; 3. Evaluation - Most datatypes self-evaluate
    (eval 1)        ; => 1
    (eval :keyword) ; => :keyword
    (eval [1 2 3])  ; => [1 2 3]

  %div.slide
    :marked
      Being hand-wavy. Actually [...more complex](http://blog.fogus.me/2012/03/27/compiling-clojure-to-javascript-pt-3-the-himera-model/),
      [especially for ClojureScript](http://blog.fogus.me/2012/04/25/the-clojurescript-compilation-pipeline/)

.slide
  %h2 Clojure evaluation - Lists
  %ul
    %li
      Lists and symbols are special
      :clojurecode
        (first-item "arg1" 'thing)
        ; => CompilerException ...
        ; Unable to resolve symbol: first-item
    %li First item is resolved to something...
    %li.slide ... more about namespaces later

.slide
  %h2 Clojure evaluation - ...function
  %ul
    %li
      If first thing in a list resolves to a function:
      %ol
        %li Evaluate the remaining items
        %li Pass them as arguments to the function
    %li
      Example...

.slide
  %h2 Function evaluation example
  :clojurecode
    (prn (str (+ 1 4) 2 3))
     'prn                  ; resolves to function
      (str (+ 1 4) 2 3)    ; evaluate
       'str                ; resolves to function
        (+ 1 4)            ; evaluate
         '+                ; resolves to function
          1                ; evaluate => 1
          4                ; evaluate => 4
        '+ 1 4             ; apply => 5
        2                  ; evaluate => 2
        3                  ; evaluate => 3
      'str 5 2 3           ; apply => "523"
    'prn "523"             ; apply
    ;   side effect: prints "523"
    nil                    ; result

.slide
  %h2 Evaluation - special forms
  %ul
    %li If it's a special form, evaluate it specially
    %li Examples...

.slide
  %h2 Special forms - def
  %ul
    %li
      %strong def
      interns symbol in current namespace
      :clojurecode
        (def symbol init?)
    %li Special because it's very low-level
    %li
      %strong defn
      is a macro around
      %strong def
      (not a special form)

.slide
  %h2 Special forms - if
  %ul
    %li
      %strong if
      evaluates conditional, then one of two branches
      :clojurecode
        (if test       ; test evaluated first
          when-true    ; evaluated if true
          when-false)  ; evaluated if false
    %li Special because parts remain unevaluated

.slide
  %h2 Special forms - do
  %ul
    %li
      %strong do
      runs the forms it contains
    %li
      discards results except the last
      :clojurecode
        (do
          (+ 10 20)       ; => 30, but discarded
          (println "Yay") ; => prints: Yay
          1234)           ; => evaluates to 1234
        ; => 1234
    %li Special because it's essentially a no-op

.slide
  %h2 Special forms - quote
  %ul
    %li
      %strong quote
      prevents evaluation of its arguments
      :clojurecode
        (quote (rm-rf "/"))
        ; => (rm-rf "/")
    %li Special because args are unevaluated
    %li
      Equivalent to the reader macro:
      %strong '
      :clojurecode
        (= (quote (a b c))
           '(a b c))

.slide
  %h2 Evaluation - ...special forms
  %ul
    %li
      About 20 special forms
      :clojurecode
        ;; definitions, bindings
        def let quote var fn
        ;; control-flow
        if do loop recur
        ;; dealing w/ Exceptions
        throw try catch
        ;; Java Interop forms
        . new set!
    %li Otherwise, those are all the evaluation rules

.slide
  %h2 Functions on hash maps
  :clojurecode
    (:a {:a 1 :b 2}) ; => 1   ; keywords are functions
    (:a #{:a :b})    ; => :a

    ; longs are not
    (0 [1 2 3])   ; => ClassCastException
    ; nor are strings
    ("a" {"a" 1}) ; => ClassCastException

    (get {:a 1 :b 2} :a)          ; => 1
    (get {:a 1 :b 2} :c)          ; => nil
    (get {:a 1 :b 2} :c :default) ; => :default

    (keys {:a 1 :b 2}) ; => (:a :b)
    (vals {:a 1 :b 2}) ; => (1 2)

    (assoc {:a 1} :b 2)     ; => {:a 1 :b 2}
    (dissoc {:a 1 :b 2} :b) ; => {:a 1}

.slide
  %h2 Clojure Basics - Sequences
  :clojurecode
    ;; (cons first rest)
    ;; cons[tructs] a new seq by
    ;; appending first to the rest
    (cons 4 '(1 2 3))    ; => (4 1 2 3)
    (cons 4 [1 2 3])     ; => (4 1 2 3)
    (cons 4 #{1 2 3})    ; => (4 1 2 3)             ;
    (cons [:b 2] {:a 1}) ; => ([:b 2] [:a 1])

.slide
  %h2 Clojure Basics - Sequences
  :clojurecode
    ;; (conj coll item)
    ;; conj[oins] efficiently
    (conj '(1 2 3) 4)    ; => (4 1 2 3)
    (conj [1 2 3] 4)     ; => [1 2 3 4]
    (conj #{1 2 3} 4)    ; => #{1 2 3 4}
    (conj {:a 1} [:b 2]) ; => {:b 2, :a 1}

    ;; (usually same concrete type)
    ;; position depends on concrete type

.slide
  %h2 Clojure Basics - Sequences
  :clojurecode
    ;; (into coll a b c ...)
    ;; conj[oins] the rest of its arguments
    ;; into the first
    (into [] 1 2 3 4)       ; => [1 2 3 4]
    (into #{} 1 2 3 4)      ; => #{1 3 2 4}
    (into {} [:a 1] [:b 2]) ; => {:a 1, :b 2}

.slide
  %h2 Binding forms
  :clojurecode
    ;; eval body with local bindings
    (let [bindings] body)

    ;; Many binding forms:

    name value         ; binds value to name

    (let [a (+ 1 2 3)] a)
    ;     | \- value = evaluated (+ 1 2 3)
    ;     \- name = a
    ; => 6

.slide
  %h2 Sequential binding forms
  :clojurecode
    [a b ...] value    ; binds a to 1st element
                       ; binds b to 2nd element
                       ; ...

    (let [[a b] '(x y)] {:thing-1 a :thing-2 b})
    ; => {:thing-1 x :thing-2 y}

    ;; unmatched names get nil
    (let [[a b] '(x)] {:thing-1 a :thing-2 b})
    ; => {:thing-1 x :thing-2 nil}

.slide
  %h2 Map-like binding forms
  :clojurecode
    ;; example value
    (def req {:type :get, :url "/"})

    ;; pulls :key out
    {name :key}
    (let [{x :type} req] x)
    ; => :get

    ;; multiple keys at once,
    {:keys [a b c]}

    (let [{:keys [type url]} req]
      {:t type :u url})
    ; => {:t :get :u "/"}

.slide
  %h2 Map-like binding forms
  :clojurecode
    ;; also assign whole to a name
    {:keys [...] :as name}

    (let [{:keys [url] :as r} req] (= r req))
    ; => true

    ;; non-keyword keys:
    {:strs [url]} value   ;; string keys
    {:syms [url]} value   ;; symbol keys

.slide
  %h2 Lazy sequences
  :clojurecode
    ;; generates integers starting at 0
    (range) ; => returns lazy sequence: (0 1 2 3 4 ...)
    (range x) ; => returns 0 to (dec x)
    (range x y) ; => returns x to (dec y)

    ;; take, drop, and nth can limit the laziness
    (take 4 (range)) ; => (0 1 2 3)
    (drop 5 (range)) ; => lazy sequence: (5 6 7 8 ...)
    (drop 5 (take 8 (range))) ; => (5 6 7)

    (nth (range) 20) ; => 20
    (nth (range) 0) ; => 0

.slide
  %h2 Functional programming
  :clojurecode
    ;; Apply a function with seq as arguments
    (apply + [1 2 3 4]) ; => 10
    ; same as: (+ 1 2 3 4)

    ;; Apply a fn with items of seqs in turn
    (map f collection)
    ; => '((f (first collection))
    ;      (f (second collection))
    ;      ...)

    ;; result is a sequence
    (map identity [1 2 3])  ; => (1 2 3)
    (map identity '(1 2 3)) ; => (1 2 3)
    (map identity #{1 2 3}) ; => (1 2 3)

.slide
  %h2 Map (cont.)
  :clojurecode
    (map str [{:a 1} [1 2] #{:a :b}])
    ; => ("{:a 1}" "[1 2]" "{:a :b}")

    ;; multiple collections stop when the shortest ends
    (map vector [:a :b :c] (range))
    ; => ((vector :a 0) (vector :b 1) (vector :c 2))
    ; => ([:a 0] [:b 1] [:c 2])

.slide
  %h2 Map is lazy - dorun
  :clojurecode
    user=> (def x (map prn [1 2 3]))
    ; => #'user/x  ;; no prints

    user=> (realized? x)
    ; => false

    user=> x
    ; (1
    ; 2
    ; 3
    ; nil nil nil) ;; prints interspersed w/ result

    user=> (dorun (map prn [1 2 3]))
    ; 1
    ; 2
    ; 3
    ; => nil ;; dorun forces realization, ignores result

.slide
  %h2 Functional programming
  :clojurecode
    ;; Fold over a list
    (reduce f initial-value? collection)
    (reduce str "" [\a \b \c \d])
    ; => like repeatedly doing: (f value next-value)
    ; => (str "" \a)    ; => "a"
    ; => (str "a" \b)   ; => "ab"
    ; => (str "ab" \c)  ; => "abc"
    ; => (str "abc" \d) ; => "abcd"

.slide
  %h2 Functional programming
  :clojurecode
    ;; Composition
    (comp f g)          ; => fn that applies g, then f
    #<core$comp$fn__4154...@2cb2e792>
    (comp str inc)      ; => fn that inc's, then str's
    ((comp str inc) 42) ; => "43"

    ;; Partial application
    (partial f other-args...)
    ; => fn that applies f to args and other-args

    (def higher (partial map (comp str inc)))
    (higher [1 2 3 4]) ; => ("2" "3" "4" "5")

    (def blue-label (partial create-label :bg "blue"))
    (blue-label "Some text") ; => blue label
    ;; from PEP 0309

.slide
  %h2 Clojure threading macros
  :clojurecode
    ;; passes x to form1, result to form2, etc.
    ;; -> = as first arg
    (-> x form1 form2 ...)
    (-> 1 (inc) (* 2) (/ 7)) ; => 4/7
    (/ (* (inc 1) 2) 7)

    ;; passes x to form1, result to form2, etc.
    ;; ->> = as last arg
    (->> x form1 form2 ...)
    (->> [:a :b] (map str) (apply str)) ; => ":a:b"
    (apply str (map str [:a :b]))

.slide
  %h2 Clojure Basics - defn
  :clojurecode
    ;; defn is a macro, which expands to def of a (fn) form
    (defn entry-printer
      "This is an example of binding"  ; doc-string
      [[key val :as entry]]            ; parameters
      (println entry "=" key "=>" val) ; body
      )

    (entry-printer [:a 1])
    ; [:a 1] = :a => 1
    ; => nil

    (dorun (map entry-printer {:a 1 :b 2}))
    ; [:a 1] = :a => 1
    ; [:b 2] = :b => 2
    ; => nil

.slide
  %h2 Namespaces - use, import
  %ul
    %li Namespaces are maps of symbols to Vars
    %li
      Use = import all symbols from another ns
      :clojurecode
        user=> (use 'clojure.repl) ;; discouraged
        user=> #'doc
        #'clojure.repl/doc
    %li
      Import = Java Class imports
      :clojurecode
        user=> (import 'java.io.Reader)
        user=> Reader
        java.io.Reader
        ;; multiple:
        user=> (import '[java.io Reader StringReader])

.slide
  %h2 Namespaces - load
  %ul
    %li
      Load = lower-level loading
    %li
      Not frequently used directly(?)
      :clojurecode
        ;; classpath-relative
        user=> (load "/clojure.set")

        ;; relative to current namespace directory
        presentron.core=> (load "something")
        ; => could not load presentron/something__init.class
        ;    or             presentron/something.clj

.slide
  %h2 Namespaces - require
  %ul
    %li
      Require = load and optionally alias another ns
      :clojurecode
        user=> (require 'clojure.repl)
        user=> (clojure.repl/doc str)

        ; :as lets you use a shorter namespace alias
        user=> (require '[clojure.repl :as repl])
        user=> (repl/doc str)

        ; :refer imports specific symbols
        user=> (require '[clojure.repl :refer (doc)])
        user=> (doc str)

        ; :refer :all = use
        user=> (require '[clojure.repl :refer :all])
        user=> (doc str)

.slide
  %h2 Namespaces - ns macro
  %ul
    %li Wrapper around the functions mentioned
    %li
      No need to quote things in this macro
      :clojurecode
        (ns com.benizi.superlibrary
          (:require [clojure.java.io :as io]
                    [clojure.string :as string])
          (:require [clojure.repl :refer (doc source)])
          (:use [clojure.repl])
          (:import [java.lang String])
          ;...
          )

.slide.comment
  %h2 Clojure Basics - Don't forget immutability
  :clojurecode
    (def a {:a 1})   ; => #'user/a
    (assoc a :b 2)   ; => {:a 1 :b 2}
    a                ; => {:a 1}

.slide
  %h2 Clojure evaluation - my experience
  %div Some things that have helped me (maybe) understand what's going on
  %ul
    %li Don't think in "infix": think of (x y z) as "apply x to y and z"
    %li
      :clojurecode
        (+ 1 2 3) ; "apply sum to 1, 2, and 3"
        (< 1 2)   ; "apply 'in-order' to 1 and 2     ; => true
        (< 1 2 3) ; "apply 'in-order' to 1, 2, and 3 ; => true
    %li Hard to remember early on when things need to be in a list
    %li If you want it to be evaluated, put it in a list
    %li If you don't want evaluation, quote it, or use a vector

.slide.comment
  %h2 Clojure Basics - Reference types - refs
  %ul
    %li Provides a wrapper around a normal entity
    %li Coordinates access to that entity
    %li Access is only available within a transaction

.slide
  %h2 Links
  %ul
    %li
      %a{:href => "https://github.com/pittsburghclj"} Pittsburgh.clj GitHub
    %li
      %a{:href => "https://github.com/pittsburghclj"} These slides

.slide
  %h2 More resources
  %ul
    %li
      Good Books
      %ul
        %li
          Excellent introduction, tour of language:
          :marked
            [Clojure Programming](http://www.clojurebook.com/)
          (better than:
          :marked
            [Programming Clojure](http://pragprog.com/book/shcloj2/programming-clojure)
          )
        %li
          More philosophical "what makes Clojure different/fun"
          :marked
            [The Joy of Clojure](http://joyofclojure.com/)
    %li
      Blog posts
      %ul
        %li
          Clojure's PersistentHashMap posts by Karl Krukow:
          :marked
            [part i](http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html),
            [part ii](http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html)
    %li
      Talks
      %ul
        %li
          Rich Hickey
          :marked
            [Are We There Yet?](http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey),
            [Simple Made Easy](http://www.infoq.com/presentations/Simple-Made-Easy) *highly recommended*

.slide
  %h2 Even more resources
  %ul
    %li
      Web sites for practicing
      %ul
        %li
          Learn through koans
          :marked
            [clojure-koans](https://github.com/functional-koans/clojure-koans)
        %li
          Practice problems
          :marked
            [4clojure](http://www.4clojure.com)
          %ul
            %li
              :marked
                user: [benizi](http://www.4clojure.com/user/benizi)
                ![benizi](/images/4clojure.png)
            %li current rank: (T-)1/27,671.
            %li Quantity. Not quality.
        %li
          Good for any language, but very math-heavy:
          :marked
            [Project Euler](http://projecteuler.net/)
    %li
      Web sites for reference
      %ul
        %li
          Community documentation
          :marked
            [ClojureDocs](http://clojuredocs.org)
        %li
          Search over code (really useful for examples)
          :marked
            [{:get 'clojure}](http://getclojure.org/)
            e.g. search for [conj](http://getclojure.org/search?q=conj&num=0)
    %li
      IRC
      %ul
        %li
          \#clojure on freenode
