%head
  %title CLI-fu
.slide
  %h1 Commandline-fu

.slide
  %h2 Execution model
  %ul
    %li
      Programs
      %ul
        %li
          Input
          %ul
            %li One file
            %li Two arrays of strings
        %li
          Output
          %ul
            %li Two files
            %li An integer

.slide
  %h2 Files
  %ul
    %li In system calls, files are just integers
    %li STDIN (file descriptor 0)
    %li STDOUT (file descriptor 1)
    %li STDERR (file descriptor 2)

  :ccode
    // writes to stdout
    write(1, "Hello, world!\n", 14);

  :rubycode
    # writes to stdout
    puts "Hello, world!"

.slide
  %h2 Two arrays of strings - #1: ARGV
  %ul
    %li ARGV (vector of arguments)
    %li Name of program is the first argument

  :ccode
    int main(int argc, char **argv) {
      int i;
      for (i=0; i<argc; i++) {
        printf("[%d]=%s\n", i, argv[i]);
      }
    }

  :rubycode
    puts "[0]=#{$0}"
    ARGV.each_with_index do |a,i|
      puts "[#{i}]=#{a}"
    end

-# >  - fix syntax

.slide
  %h2 Two arrays of strings - #2: ENV
  %ul
    %li Treated as set of key-value pairs
    %li List of strings split on first "=" character

  :ccode
    int main(int argc, char **argv, char **env) { // not portable
      int i;
      for (i=0; env[i]; i++) {
        printf("ENV[%d]: %s\n", i, env[i]);
      }
    }

.slide
  %h2 Output an integer
  %ul
    %li "Exit status", "Error code"
    %li 0 = everything OK
    %li not 0 (often 1) = something went wrong

  :ccode
    int main(void) {
      return 1;
    }

  :bashlexer
    $ true ; echo $?
    # => 0
    $ false ; echo $?
    # => 1

.slide
  %h2 How shells work
  %ul
    %li Find the command(s) to run
    %li Wire up standard files
    %li Execute the pipeline
    %li Do control flow based on exit codes

  :bashlexer
    $ /bin/echo pizza | grep z
    # /bin/echo = fully qualified, no need to search
    # grep = check each `:`-separated entry in `$PATH`
    # open pipe = set of two files (UNIX sockets)
    # run /bin/echo with fd1 = write end of pipe
    # run /bin/grep with fd0 = read end of pipe

.slide
  %h2 Portable shell has very few constructs
  :bashlexer
    if # condition
    then # command
    elif # condition
    then # command
    else # command
    fi

  :bashlexer
    case ... in
      pattern)
        # command
        ;;
    esac

  :bashlexer
    while # condition
    do # command
    done

  :bashlexer
    for x in ...
    do # command
    done

.slide
  %h2 Surprise! "condition" = command
  :bashlexer
    if # command
    then # command
    elif # command
    then # command
    else # command
    fi

  :bashlexer
    case ... in
      pattern)
        # command
        ;;
    esac

  :bashlexer
    while # command
    do # command
    done

  :bashlexer
    for x in ...
    do # command
    done

.slide
  %h2 Double surprise! "[" is a command
  :bashlexer
    $ which [
    # => /bin/[

    $ if [ -z "$var" ]
    # if $var is empty:
    # runs ["[", "-z", "", "]"]

  %ul
    %li Use `[[ ... ]]` if your shell supports it
    %li POSIX allows `[[` and `]]` to have different semantics
    %li `bash` and `zsh` both do this
    %li More resilient (syntax-enhanced)

  :bashlexer
    $ var="directory with spaces"
    $ [ -d $var ]
    # dash: 2: [: directory: unexpected operator
    # bash: [: too many arguments
    ## works fine in zsh... where arg splitting is different

.slide
  %h2 Shell logic and variables
  %ul
    %li Can set variables
    %li ENV variables are inherited
    %li `export` creates new ENV vars
    %li `&&` and `||` (`&&` binds tightly)

.slide
  %h2 Quoting
  %ul
    %li Backslash = escape character
    %li Single quotes retain everything
    %li
      Double quotes retain everything except:
      %ul
        %li
          :marked
            ```
            $ => parameter expansion
            ```
        %li
          :marked
            ```
            ` => command substitution
            ```
        %li
          Backslash only escapes:
          :marked
            ```
            $ ` " \ &lt;newline>
            ```
    %li
      Always need to be quoted:
      :marked
        ```
        | & ; &lt; > ( ) $ ` \ " ' &lt;space> &lt;tab> &lt;newline>
        ```
    %li
      Sometimes need to be quoted:
      :marked
        ```
        * ? [ # ~ = %
        ```
    %li
      HEREDOCs:
      :marked

.slide
  %h2 Commands
  %ul
    %li `awk`
    %li `sed`
    %li `xargs`
    %li `jq`
