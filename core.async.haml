%head
  %title Short Intro to core.async

.slide
  %h1
    Short Intro to
    :marked
      [core.async](https://github.com/clojure/core.async)

.slide
  %h2 Sources
  %ul
    %li
      David Nolen - Clojure Library Core.async for Asynchronous Programming
      %ul
        %li
          :marked
            [YouTube talk](https://www.youtube.com/watch?v=AhxcGGeh5ho)
        %li
          :marked
            [GitHub code used in samples](https://github.com/swannodette/hs-async)
    %li
      Timothy Baldridge - Clojure/conj 2013 talk on core.async
      %ul
        %li
          :marked
            [YouTube video](https://www.youtube.com/watch?v=enwIIGzhahw)
        %li
          :marked
            [GitHub code](https://github.com/halgari/clojure-conj-2013-core.async-examples)
    %li
      Live coding in
      :marked
        [Emacs-live](http://overtone.github.io/emacs-live/)

.slide
  %h2 About Me
  %ul
    %li
      :marked
        [Benjamin R. Haskell](http://benizi.com/):
        Twitter [@benizi](https://twitter.com/benizi),
        GitHub [benizi](https://github.com/benizi)
    %li
      Day Job:
      :marked
        [Forever&trade;](http://www.4moms.com/)
      (mostly Ruby)
    %li.slide
      :marked
        [#1 (tied) on 4clojure](http://www.4clojure.com/users) (quantity, not quality)
        ![4clojure stats](/images/4clojure.png)

.slide
  %h2 About core.async
  %ul
    %li Implementation of Communicating Sequential Processes (CSP)
    %li Provides a Channel abstraction
    %li Similar to how Go(lang) implemented Channels
    %li Works well in both Clojure and ClojureScript

.slide
  %h2 Leiningen coordinates
  :clojurecode
    ;; in project.clj
    (defproject my.project "0.1.0-SNAPSHOT"
      ;; ...
      :dependencies [ ;; ...
      [org.clojure/core.async "0.1.267.0-0d7780-alpha"] ;; ...
  :clojurecode
    ;; in your code that uses core.async
    (ns my.project.core
      (:require [core.async :as async
                 ;; commonly:
                 :refer (go put! take!)]))

.slide
  %h2 Channels
  %ul
    %li
      You can create them
      %ul
        %li
          without a buffer
          :clojurecode
            (def a-channel (chan))
        %li
          :marked
            with a buffer of size `n`
          :clojurecode
            (def a-channel (chan n))
          :marked
            [chan](http://clojure.github.io/core.async/index.html#clojure.core.async/chan)

.slide
  %h2 Channels - close
  %ul
    %li
      You can close them
      :clojurecode
        (close! a-channel)
      :marked
        [close!](http://clojure.github.io/core.async/index.html#clojure.core.async/close!)

.slide
  %h2 Channels - put
  %ul
    %li
      You can put things onto them
      %ul
        %li
          parking - only in go block
          :clojurecode
            (>! a-channel 100)
        %li
          blocking
          :clojurecode
            (>!! a-channel 100)
        %li
          non-blocking
          :clojurecode
            (put! a-channel 100)
      :marked
        [&gt;!](http://clojure.github.io/core.async/index.html#clojure.core.async/%3E!) |
        [&gt;!!](http://clojure.github.io/core.async/index.html#clojure.core.async/%3E!!) |
        [put!](http://clojure.github.io/core.async/index.html#clojure.core.async/put!)

.slide
  %h2 Channels - take
  %ul
    %li
      You can take things off of them
      %ul
        %li
          parking - only in go block
          :clojurecode
            (<! a-channel)
        %li
          blocking
          :clojurecode
            (<!! a-channel)
        %li
          non-blocking
          :clojurecode
            (take! a-channel)
      :marked
        [&lt;!](http://clojure.github.io/core.async/index.html#clojure.core.async/%3D!) |
        [&lt;!!](http://clojure.github.io/core.async/index.html#clojure.core.async/%3D!!) |
        [take!](http://clojure.github.io/core.async/index.html#clojure.core.async/take!)

.slide
  %h2 Go macro
  %iframe{src: 'http://clojure.github.io/core.async/index.html#clojure.core.async/go', scrolling: 'no', style: 'width: 80%; height: 10em; overflow: hidden'}
  %ul.slide
    %li
      Rewrites your code using crazy inversion-of-control macros, creating a
      state machine scaffolding for turning blocking takes/puts into parked,
      individual lightweight threads

.slide
  %h2 Go macro
  %ul
    %li{style: 'text-decoration: line-through'}
      Rewrites your code using crazy inversion-of-control macros, creating a
      state machine scaffolding for turning blocking takes/puts into parked,
      individual lightweight threads
    %li
      Allows you to write blocking code as if it weren't
      :clojurecode
        (let [c (chan)]
          (go
            (println (<! c)))
          (go
            (>! c :some-value)))
        ;; => prints :some-value
        ;; despite the take appearing before the put

.slide
  %h2 alts! and alts!!
  %ul
    %li Perform the next available operation on a set of channels
    %li
      Go(lang) select, similar to Linux select call
      :clojurecode
        (def a (chan))
        (def b (chan))
        (put! a 42)
        (alts!! [a b])
    %li alts! - in a go block
    %li alts!! - outside
    :marked
      [alts!](http://clojure.github.io/core.async/index.html#clojure.core.async/alts!) |
      [alts!!](http://clojure.github.io/core.async/index.html#clojure.core.async/alts!!)

.slide
  %h2 Types of channels
  %h3 timeout
  %ul
    %li Times out after n milliseconds
    %li
      Useful with alts!/alts!!
      :clojurecode
        (let [c (chan)
              t (timeout 100)]
          (let [[v ch] (alts!! [c t])]
            (prn {:ch ch :v v})))

.slide
  %h2 Types of channels
  %h3 dropping buffer
  %ul
    %li
      When full, puts can complete, but won't have any effect
      :clojurecode
        (async/dropping-buffer n)
    :marked
      [dropping-buffer](http://clojure.github.io/core.async/index.html#clojure.core.async/dropping-buffer)

.slide
  %h2 Types of channels
  %h3 sliding buffer
  %ul
    %li
      When full, puts can complete, but first item still in the channel is dropped
      :clojurecode
        (async/sliding-buffer n)
    :marked
      [sliding-buffer](http://clojure.github.io/core.async/index.html#clojure.core.async/sliding-buffer)
